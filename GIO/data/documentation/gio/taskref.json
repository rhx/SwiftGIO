{"primaryContentSections":[{"kind":"declarations","declarations":[{"tokens":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"TaskRef"}],"languages":["swift"],"platforms":["macOS"]}]},{"kind":"content","content":[{"anchor":"Asynchronous-operations","level":2,"type":"heading","text":"Asynchronous operations"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The most common usage of "},{"type":"codeVoice","code":"GTask"},{"type":"text","text":" is as a [iface"},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/AsyncResult"},{"type":"text","text":"], to"},{"type":"text","text":" "},{"type":"text","text":"manage data during an asynchronous operation. You call"},{"type":"text","text":" "},{"type":"text","text":"[ctor"},{"type":"codeVoice","code":"Gio.Task.new"},{"type":"text","text":"] in the ‘start’ method, followed by"},{"type":"text","text":" "},{"type":"text","text":"[method"},{"type":"codeVoice","code":"Gio.Task.set_task_data"},{"type":"text","text":"] and the like if you need to keep some"},{"type":"text","text":" "},{"type":"text","text":"additional data associated with the task, and then pass the"},{"type":"text","text":" "},{"type":"text","text":"task object around through your asynchronous operation."},{"type":"text","text":" "},{"type":"text","text":"Eventually, you will call a method such as"},{"type":"text","text":" "},{"type":"text","text":"[method"},{"type":"codeVoice","code":"Gio.Task.return_pointer"},{"type":"text","text":"] or [method"},{"type":"codeVoice","code":"Gio.Task.return_error"},{"type":"text","text":"], which"},{"type":"text","text":" "},{"type":"text","text":"will save the value you give it and then invoke the task’s callback"},{"type":"text","text":" "},{"type":"text","text":"function in the thread-default main context (see"},{"type":"text","text":" "},{"type":"text","text":"[method"},{"type":"codeVoice","code":"GLib.MainContext.push_thread_default"},{"type":"text","text":"])"},{"type":"text","text":" "},{"type":"text","text":"where it was created (waiting until the next iteration of the main"},{"type":"text","text":" "},{"type":"text","text":"loop first, if necessary). The caller will pass the "},{"type":"codeVoice","code":"GTask"},{"type":"text","text":" back to"},{"type":"text","text":" "},{"type":"text","text":"the operation’s finish function (as a [iface"},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/AsyncResult"},{"type":"text","text":"]), and you can"},{"type":"text","text":" "},{"type":"text","text":"use [method"},{"type":"codeVoice","code":"Gio.Task.propagate_pointer"},{"type":"text","text":"] or the like to extract the"},{"type":"text","text":" "},{"type":"text","text":"return value."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Using "},{"type":"codeVoice","code":"GTask"},{"type":"text","text":" requires the thread-default [struct[MainContext](\/\/documentation\/glib\/maincontext] from when"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"GTask"},{"type":"text","text":" was constructed to be running at least until the task has"},{"type":"text","text":" "},{"type":"text","text":"completed and its data has been freed."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a "},{"type":"codeVoice","code":"GTask"},{"type":"text","text":" has been constructed and its callback set, it is an error to"},{"type":"text","text":" "},{"type":"text","text":"not call "},{"type":"codeVoice","code":"g_task_return_*()"},{"type":"text","text":" on it. GLib will warn at runtime if this happens"},{"type":"text","text":" "},{"type":"text","text":"(since 2.76)."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here is an example for using "},{"type":"codeVoice","code":"GTask"},{"type":"text","text":" as a [iface"},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/AsyncResult"},{"type":"text","text":"]:"}]},{"type":"codeListing","syntax":"c","code":["typedef struct {","  CakeFrostingType frosting;","  char *message;","} DecorationData;","","static void","decoration_data_free (DecorationData *decoration)","{","  g_free (decoration->message);","  g_slice_free (DecorationData, decoration);","}","","static void","baked_cb (Cake     *cake,","          gpointer  user_data)","{","  GTask *task = user_data;","  DecorationData *decoration = g_task_get_task_data (task);","  GError *error = NULL;","","  if (cake == NULL)","    {","      g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,","                               \"Go to the supermarket\");","      g_object_unref (task);","      return;","    }","","  if (!cake_decorate (cake, decoration->frosting, decoration->message, &error))","    {","      g_object_unref (cake);","      \/\/ `g_task_return_error()` takes ownership of error","      g_task_return_error (task, error);","      g_object_unref (task);","      return;","    }","","  g_task_return_pointer (task, cake, g_object_unref);","  g_object_unref (task);","}","","void","baker_bake_cake_async (Baker               *self,","                       guint                radius,","                       CakeFlavor           flavor,","                       CakeFrostingType     frosting,","                       const char          *message,","                       GCancellable        *cancellable,","                       GAsyncReadyCallback  callback,","                       gpointer             user_data)","{","  GTask *task;","  DecorationData *decoration;","  Cake  *cake;","","  task = g_task_new (self, cancellable, callback, user_data);","  if (radius < 3)","    {","      g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_TOO_SMALL,","                               \"`ucm` radius cakes are silly\",","                               radius);","      g_object_unref (task);","      return;","    }","","  cake = _baker_get_cached_cake (self, radius, flavor, frosting, message);","  if (cake != NULL)","    {","      \/\/ `_baker_get_cached_cake()` returns a reffed cake","      g_task_return_pointer (task, cake, g_object_unref);","      g_object_unref (task);","      return;","    }","","  decoration = g_slice_new (DecorationData);","  decoration->frosting = frosting;","  decoration->message = g_strdup (message);","  g_task_set_task_data (task, decoration, (GDestroyNotify) decoration_data_free);","","  _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);","}","","Cake *","baker_bake_cake_finish (Baker         *self,","                        GAsyncResult  *result,","                        GError       **error)","{","  g_return_val_if_fail (g_task_is_valid (result, self), NULL);","","  return g_task_propagate_pointer (G_TASK (result), error);","}"]},{"anchor":"Chained-asynchronous-operations","level":2,"type":"heading","text":"Chained asynchronous operations"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"GTask"},{"type":"text","text":" also tries to simplify asynchronous operations that"},{"type":"text","text":" "},{"type":"text","text":"internally chain together several smaller asynchronous"},{"type":"text","text":" "},{"type":"text","text":"operations. [method"},{"type":"codeVoice","code":"Gio.Task.get_cancellable"},{"type":"text","text":"], [method"},{"type":"codeVoice","code":"Gio.Task.get_context"},{"type":"text","text":"],"},{"type":"text","text":" "},{"type":"text","text":"and [method"},{"type":"codeVoice","code":"Gio.Task.get_priority"},{"type":"text","text":"] allow you to get back the task’s"},{"type":"text","text":" "},{"type":"text","text":"[class"},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Cancellable"},{"type":"text","text":"], [struct[MainContext](\/\/documentation\/glib\/maincontext], and"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"iface.AsyncResult.html#io-priority"},{"type":"text","text":" "},{"type":"text","text":"when starting a new subtask, so you don’t have to keep track"},{"type":"text","text":" "},{"type":"text","text":"of them yourself. [method"},{"type":"codeVoice","code":"Gio.Task.attach_source"},{"type":"text","text":"] simplifies the case"},{"type":"text","text":" "},{"type":"text","text":"of waiting for a source to fire (automatically using the correct"},{"type":"text","text":" "},{"type":"text","text":"[struct[MainContext](\/\/documentation\/glib\/maincontext] and priority)."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here is an example for chained asynchronous operations:"}]},{"type":"codeListing","syntax":"c","code":["typedef struct {","  Cake *cake;","  CakeFrostingType frosting;","  char *message;","} BakingData;","","static void","decoration_data_free (BakingData *bd)","{","  if (bd->cake)","    g_object_unref (bd->cake);","  g_free (bd->message);","  g_slice_free (BakingData, bd);","}","","static void","decorated_cb (Cake         *cake,","              GAsyncResult *result,","              gpointer      user_data)","{","  GTask *task = user_data;","  GError *error = NULL;","","  if (!cake_decorate_finish (cake, result, &error))","    {","      g_object_unref (cake);","      g_task_return_error (task, error);","      g_object_unref (task);","      return;","    }","","  \/\/ `baking_data_free()` will drop its ref on the cake, so we have to","  \/\/ take another here to give to the caller.","  g_task_return_pointer (task, g_object_ref (cake), g_object_unref);","  g_object_unref (task);","}","","static gboolean","decorator_ready (gpointer user_data)","{","  GTask *task = user_data;","  BakingData *bd = g_task_get_task_data (task);","","  cake_decorate_async (bd->cake, bd->frosting, bd->message,","                       g_task_get_cancellable (task),","                       decorated_cb, task);","","  return G_SOURCE_REMOVE;","}","","static void","baked_cb (Cake     *cake,","          gpointer  user_data)","{","  GTask *task = user_data;","  BakingData *bd = g_task_get_task_data (task);","  GError *error = NULL;","","  if (cake == NULL)","    {","      g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,","                               \"Go to the supermarket\");","      g_object_unref (task);","      return;","    }","","  bd->cake = cake;","","  \/\/ Bail out now if the user has already cancelled","  if (g_task_return_error_if_cancelled (task))","    {","      g_object_unref (task);","      return;","    }","","  if (cake_decorator_available (cake))","    decorator_ready (task);","  else","    {","      GSource *source;","","      source = cake_decorator_wait_source_new (cake);","      \/\/ Attach `source` to `task`’s GMainContext and have it call","      \/\/ `decorator_ready()` when it is ready.","      g_task_attach_source (task, source, decorator_ready);","      g_source_unref (source);","    }","}","","void","baker_bake_cake_async (Baker               *self,","                       guint                radius,","                       CakeFlavor           flavor,","                       CakeFrostingType     frosting,","                       const char          *message,","                       gint                 priority,","                       GCancellable        *cancellable,","                       GAsyncReadyCallback  callback,","                       gpointer             user_data)","{","  GTask *task;","  BakingData *bd;","","  task = g_task_new (self, cancellable, callback, user_data);","  g_task_set_priority (task, priority);","","  bd = g_slice_new0 (BakingData);","  bd->frosting = frosting;","  bd->message = g_strdup (message);","  g_task_set_task_data (task, bd, (GDestroyNotify) baking_data_free);","","  _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);","}","","Cake *","baker_bake_cake_finish (Baker         *self,","                        GAsyncResult  *result,","                        GError       **error)","{","  g_return_val_if_fail (g_task_is_valid (result, self), NULL);","","  return g_task_propagate_pointer (G_TASK (result), error);","}"]},{"anchor":"Asynchronous-operations-from-synchronous-ones","level":2,"type":"heading","text":"Asynchronous operations from synchronous ones"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can use [method"},{"type":"codeVoice","code":"Gio.Task.run_in_thread"},{"type":"text","text":"] to turn a synchronous"},{"type":"text","text":" "},{"type":"text","text":"operation into an asynchronous one, by running it in a thread."},{"type":"text","text":" "},{"type":"text","text":"When it completes, the result will be dispatched to the thread-default main"},{"type":"text","text":" "},{"type":"text","text":"context (see [method"},{"type":"codeVoice","code":"GLib.MainContext.push_thread_default"},{"type":"text","text":"]) where the "},{"type":"codeVoice","code":"GTask"},{"type":"text","text":" "},{"type":"text","text":"was created."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Running a task in a thread:"}]},{"type":"codeListing","syntax":"c","code":["typedef struct {","  guint radius;","  CakeFlavor flavor;","  CakeFrostingType frosting;","  char *message;","} CakeData;","","static void","cake_data_free (CakeData *cake_data)","{","  g_free (cake_data->message);","  g_slice_free (CakeData, cake_data);","}","","static void","bake_cake_thread (GTask         *task,","                  gpointer       source_object,","                  gpointer       task_data,","                  GCancellable  *cancellable)","{","  Baker *self = source_object;","  CakeData *cake_data = task_data;","  Cake *cake;","  GError *error = NULL;","","  cake = bake_cake (baker, cake_data->radius, cake_data->flavor,","                    cake_data->frosting, cake_data->message,","                    cancellable, &error);","  if (cake)","    g_task_return_pointer (task, cake, g_object_unref);","  else","    g_task_return_error (task, error);","}","","void","baker_bake_cake_async (Baker               *self,","                       guint                radius,","                       CakeFlavor           flavor,","                       CakeFrostingType     frosting,","                       const char          *message,","                       GCancellable        *cancellable,","                       GAsyncReadyCallback  callback,","                       gpointer             user_data)","{","  CakeData *cake_data;","  GTask *task;","","  cake_data = g_slice_new (CakeData);","  cake_data->radius = radius;","  cake_data->flavor = flavor;","  cake_data->frosting = frosting;","  cake_data->message = g_strdup (message);","  task = g_task_new (self, cancellable, callback, user_data);","  g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);","  g_task_run_in_thread (task, bake_cake_thread);","  g_object_unref (task);","}","","Cake *","baker_bake_cake_finish (Baker         *self,","                        GAsyncResult  *result,","                        GError       **error)","{","  g_return_val_if_fail (g_task_is_valid (result, self), NULL);","","  return g_task_propagate_pointer (G_TASK (result), error);","}"]},{"anchor":"Adding-cancellability-to-uncancellable-tasks","level":2,"type":"heading","text":"Adding cancellability to uncancellable tasks"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Finally, [method"},{"type":"codeVoice","code":"Gio.Task.run_in_thread"},{"type":"text","text":"] and"},{"type":"text","text":" "},{"type":"text","text":"[method"},{"type":"codeVoice","code":"Gio.Task.run_in_thread_sync"},{"type":"text","text":"] can be used to turn an uncancellable"},{"type":"text","text":" "},{"type":"text","text":"operation into a cancellable one. If you call"},{"type":"text","text":" "},{"type":"text","text":"[method"},{"type":"codeVoice","code":"Gio.Task.set_return_on_cancel"},{"type":"text","text":"], passing "},{"type":"codeVoice","code":"TRUE"},{"type":"text","text":", then if the task’s"},{"type":"text","text":" "},{"type":"text","text":"[class"},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Cancellable"},{"type":"text","text":"] is cancelled, it will return control back to the"},{"type":"text","text":" "},{"type":"text","text":"caller immediately, while allowing the task thread to continue running in the"},{"type":"text","text":" "},{"type":"text","text":"background (and simply discarding its result when it finally does finish)."},{"type":"text","text":" "},{"type":"text","text":"Provided that the task thread is careful about how it uses"},{"type":"text","text":" "},{"type":"text","text":"locks and other externally-visible resources, this allows you"},{"type":"text","text":" "},{"type":"text","text":"to make ‘GLib-friendly’ asynchronous and cancellable"},{"type":"text","text":" "},{"type":"text","text":"synchronous variants of blocking APIs."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Cancelling a task:"}]},{"type":"codeListing","syntax":"c","code":["static void","bake_cake_thread (GTask         *task,","                  gpointer       source_object,","                  gpointer       task_data,","                  GCancellable  *cancellable)","{","  Baker *self = source_object;","  CakeData *cake_data = task_data;","  Cake *cake;","  GError *error = NULL;","","  cake = bake_cake (baker, cake_data->radius, cake_data->flavor,","                    cake_data->frosting, cake_data->message,","                    &error);","  if (error)","    {","      g_task_return_error (task, error);","      return;","    }","","  \/\/ If the task has already been cancelled, then we don’t want to add","  \/\/ the cake to the cake cache. Likewise, we don’t  want to have the","  \/\/ task get cancelled in the middle of updating the cache.","  \/\/ `g_task_set_return_on_cancel()` will return `true` here if it managed","  \/\/ to disable return-on-cancel, or `false` if the task was cancelled","  \/\/ before it could.","  if (g_task_set_return_on_cancel (task, FALSE))","    {","      \/\/ If the caller cancels at this point, their","      \/\/ GAsyncReadyCallback won’t be invoked until we return,","      \/\/ so we don’t have to worry that this code will run at","      \/\/ the same time as that code does. But if there were","      \/\/ other functions that might look at the cake cache,","      \/\/ then we’d probably need a GMutex here as well.","      baker_add_cake_to_cache (baker, cake);","      g_task_return_pointer (task, cake, g_object_unref);","    }","}","","void","baker_bake_cake_async (Baker               *self,","                       guint                radius,","                       CakeFlavor           flavor,","                       CakeFrostingType     frosting,","                       const char          *message,","                       GCancellable        *cancellable,","                       GAsyncReadyCallback  callback,","                       gpointer             user_data)","{","  CakeData *cake_data;","  GTask *task;","","  cake_data = g_slice_new (CakeData);","","  ...","","  task = g_task_new (self, cancellable, callback, user_data);","  g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);","  g_task_set_return_on_cancel (task, TRUE);","  g_task_run_in_thread (task, bake_cake_thread);","}","","Cake *","baker_bake_cake_sync (Baker               *self,","                      guint                radius,","                      CakeFlavor           flavor,","                      CakeFrostingType     frosting,","                      const char          *message,","                      GCancellable        *cancellable,","                      GError             **error)","{","  CakeData *cake_data;","  GTask *task;","  Cake *cake;","","  cake_data = g_slice_new (CakeData);","","  ...","","  task = g_task_new (self, cancellable, NULL, NULL);","  g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);","  g_task_set_return_on_cancel (task, TRUE);","  g_task_run_in_thread_sync (task, bake_cake_thread);","","  cake = g_task_propagate_pointer (task, error);","  g_object_unref (task);","  return cake;","}"]},{"anchor":"Porting-from-classdocGIOdocumentationGIOSimpleAsyncResult","level":2,"type":"heading","text":"Porting from [class``doc:\/\/GIO\/documentation\/GIO\/SimpleAsyncResult``]"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"GTask"},{"type":"text","text":"’s API attempts to be simpler than [class"},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/SimpleAsyncResult"},{"type":"text","text":"]’s"},{"type":"text","text":" "},{"type":"text","text":"in several ways:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"You can save task-specific data with [method"},{"type":"codeVoice","code":"Gio.Task.set_task_data"},{"type":"text","text":"], and"},{"type":"text","text":" "},{"type":"text","text":"retrieve it later with [method"},{"type":"codeVoice","code":"Gio.Task.get_task_data"},{"type":"text","text":"]. This replaces the"},{"type":"text","text":" "},{"type":"text","text":"abuse of [method"},{"type":"codeVoice","code":"Gio.SimpleAsyncResult.set_op_res_gpointer"},{"type":"text","text":"] for the same"},{"type":"text","text":" "},{"type":"text","text":"purpose with [class"},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/SimpleAsyncResult"},{"type":"text","text":"]."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In addition to the task data, "},{"type":"codeVoice","code":"GTask"},{"type":"text","text":" also keeps track of the"},{"type":"text","text":" "},{"overridingTitleInlineContent":[{"type":"text","text":"priority"}],"isActive":true,"type":"reference","identifier":"iface.AsyncResult.html#io-priority","overridingTitle":"priority"},{"type":"text","text":", [class"},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Cancellable"},{"type":"text","text":"],"},{"type":"text","text":" "},{"type":"text","text":"and [struct[MainContext](\/\/documentation\/glib\/maincontext] associated with the task, so tasks that"},{"type":"text","text":" "},{"type":"text","text":"consist of a chain of simpler asynchronous operations will have easy access"},{"type":"text","text":" "},{"type":"text","text":"to those values when starting each sub-task."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"[method"},{"type":"codeVoice","code":"Gio.Task.return_error_if_cancelled"},{"type":"text","text":"] provides simplified"},{"type":"text","text":" "},{"type":"text","text":"handling for cancellation. In addition, cancellation"},{"type":"text","text":" "},{"type":"text","text":"overrides any other "},{"type":"codeVoice","code":"GTask"},{"type":"text","text":" return value by default, like"},{"type":"text","text":" "},{"type":"text","text":"[class"},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/SimpleAsyncResult"},{"type":"text","text":"] does when"},{"type":"text","text":" "},{"type":"text","text":"[method"},{"type":"codeVoice","code":"Gio.SimpleAsyncResult.set_check_cancellable"},{"type":"text","text":"] is called."},{"type":"text","text":" "},{"type":"text","text":"(You can use [method"},{"type":"codeVoice","code":"Gio.Task.set_check_cancellable"},{"type":"text","text":"] to turn off that"},{"type":"text","text":" "},{"type":"text","text":"behavior.) On the other hand, [method"},{"type":"codeVoice","code":"Gio.Task.run_in_thread"},{"type":"text","text":"]"},{"type":"text","text":" "},{"type":"text","text":"guarantees that it will always run your"},{"type":"text","text":" "},{"type":"codeVoice","code":"task_func"},{"type":"text","text":", even if the task’s [class"},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Cancellable"},{"type":"text","text":"]"},{"type":"text","text":" "},{"type":"text","text":"is already cancelled before the task gets a chance to run;"},{"type":"text","text":" "},{"type":"text","text":"you can start your "},{"type":"codeVoice","code":"task_func"},{"type":"text","text":" with a"},{"type":"text","text":" "},{"type":"text","text":"[method"},{"type":"codeVoice","code":"Gio.Task.return_error_if_cancelled"},{"type":"text","text":"] check if you need the"},{"type":"text","text":" "},{"type":"text","text":"old behavior."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The ‘return’ methods (eg, [method"},{"type":"codeVoice","code":"Gio.Task.return_pointer"},{"type":"text","text":"])"},{"type":"text","text":" "},{"type":"text","text":"automatically cause the task to be ‘completed’ as well, and"},{"type":"text","text":" "},{"type":"text","text":"there is no need to worry about the ‘complete’ vs ‘complete in idle’"},{"type":"text","text":" "},{"type":"text","text":"distinction. ("},{"type":"codeVoice","code":"GTask"},{"type":"text","text":" automatically figures out"},{"type":"text","text":" "},{"type":"text","text":"whether the task’s callback can be invoked directly, or"},{"type":"text","text":" "},{"type":"text","text":"if it needs to be sent to another [struct[MainContext](\/\/documentation\/glib\/maincontext], or delayed"},{"type":"text","text":" "},{"type":"text","text":"until the next iteration of the current [struct"},{"type":"reference","isActive":true,"identifier":"\/\/documentation\/glib\/maincontext]."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The ‘finish’ functions for "},{"type":"codeVoice","code":"GTask"},{"type":"text","text":" based operations are generally"},{"type":"text","text":" "},{"type":"text","text":"much simpler than [class"},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/SimpleAsyncResult"},{"type":"text","text":"] ones, normally consisting"},{"type":"text","text":" "},{"type":"text","text":"of only a single call to [method"},{"type":"codeVoice","code":"Gio.Task.propagate_pointer"},{"type":"text","text":"] or the like."},{"type":"text","text":" "},{"type":"text","text":"Since [method"},{"type":"codeVoice","code":"Gio.Task.propagate_pointer"},{"type":"text","text":"] ‘steals’ the return value from"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"GTask"},{"type":"text","text":", it is not necessary to juggle pointers around to"},{"type":"text","text":" "},{"type":"text","text":"prevent it from being freed twice."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"With [class"},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/SimpleAsyncResult"},{"type":"text","text":"], it was common to call"},{"type":"text","text":" "},{"type":"text","text":"[method"},{"type":"codeVoice","code":"Gio.SimpleAsyncResult.propagate_error"},{"type":"text","text":"] from the"},{"type":"text","text":" "},{"type":"codeVoice","code":"_finish()"},{"type":"text","text":" wrapper function, and have"},{"type":"text","text":" "},{"type":"text","text":"virtual method implementations only deal with successful"},{"type":"text","text":" "},{"type":"text","text":"returns. This behavior is deprecated, because it makes it"},{"type":"text","text":" "},{"type":"text","text":"difficult for a subclass to chain to a parent class’s async"},{"type":"text","text":" "},{"type":"text","text":"methods. Instead, the wrapper function should just be a"},{"type":"text","text":" "},{"type":"text","text":"simple wrapper, and the virtual method should call an"},{"type":"text","text":" "},{"type":"text","text":"appropriate "},{"type":"codeVoice","code":"g_task_propagate_"},{"type":"text","text":" function."},{"type":"text","text":" "},{"type":"text","text":"Note that wrapper methods can now use"},{"type":"text","text":" "},{"type":"text","text":"[method"},{"type":"codeVoice","code":"Gio.AsyncResult.legacy_propagate_error"},{"type":"text","text":"] to do old-style"},{"type":"text","text":" "},{"type":"text","text":"[class"},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/SimpleAsyncResult"},{"type":"text","text":"] error-returning behavior, and"},{"type":"text","text":" "},{"type":"text","text":"[method"},{"type":"codeVoice","code":"Gio.AsyncResult.is_tagged"},{"type":"text","text":"] to check if a result is tagged as"},{"type":"text","text":" "},{"type":"text","text":"having come from the "},{"type":"codeVoice","code":"_async()"},{"type":"text","text":" wrapper"},{"type":"text","text":" "},{"type":"text","text":"function (for ‘short-circuit’ results, such as when passing"},{"type":"text","text":" "},{"type":"codeVoice","code":"0"},{"type":"text","text":" to [method"},{"type":"codeVoice","code":"Gio.InputStream.read_async"},{"type":"text","text":"])."}]}]}]},{"anchor":"Thread-safety-considerations","level":2,"type":"heading","text":"Thread-safety considerations"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Due to some infelicities in the API design, there is a"},{"type":"text","text":" "},{"type":"text","text":"thread-safety concern that users of "},{"type":"codeVoice","code":"GTask"},{"type":"text","text":" have to be aware of:"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the "},{"type":"codeVoice","code":"main"},{"type":"text","text":" thread drops its last reference to the source object"},{"type":"text","text":" "},{"type":"text","text":"or the task data before the task is finalized, then the finalizers"},{"type":"text","text":" "},{"type":"text","text":"of these objects may be called on the worker thread."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is a problem if the finalizers use non-threadsafe API, and"},{"type":"text","text":" "},{"type":"text","text":"can lead to hard-to-debug crashes. Possible workarounds include:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Clear task data in a signal handler for "},{"type":"codeVoice","code":"notify"},{"type":"text","text":"completed``"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Keep iterating a main context in the main thread and defer"},{"type":"text","text":" "},{"type":"text","text":"dropping the reference to the source object to that main"},{"type":"text","text":" "},{"type":"text","text":"context when the task is finalized"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef"},{"type":"text","text":" type acts as a lightweight Swift reference to an underlying "},{"type":"codeVoice","code":"GTask"},{"type":"text","text":" instance."},{"type":"text","text":" "},{"type":"text","text":"It exposes methods that can operate on this data type through "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskProtocol"},{"type":"text","text":" conformance."},{"type":"text","text":" "},{"type":"text","text":"Use "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef"},{"type":"text","text":" only as an "},{"type":"codeVoice","code":"unowned"},{"type":"text","text":" reference to an existing "},{"type":"codeVoice","code":"GTask"},{"type":"text","text":" instance."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Use "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Task"},{"type":"text","text":" (instead of "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef"},{"type":"text","text":") if you want to use Automatic Reference Counting for memory management of the underlying "},{"type":"codeVoice","code":"GTask"},{"type":"text","text":" instance."}]}],"type":"aside","name":"Note"}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/gio\/taskref"],"traits":[{"interfaceLanguage":"swift"}]}],"relationshipsSections":[{"identifiers":["doc:\/\/GIO\/documentation\/GIO\/AsyncResultProtocol","doc:\/\/GIO\/4GLib14PointerWrapperP","doc:\/\/GIO\/10GLibObject14GWeakCapturingP","doc:\/\/GIO\/10GLibObject0B8ProtocolP","doc:\/\/GIO\/documentation\/GIO\/TaskProtocol"],"kind":"relationships","title":"Conforms To","type":"conformsTo"}],"identifier":{"url":"doc:\/\/GIO\/documentation\/GIO\/TaskRef","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"GTask"},{"type":"text","text":" represents and manages a cancellable ‘task’."}],"kind":"symbol","metadata":{"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"TaskRef"}],"title":"TaskRef","roleHeading":"Structure","role":"symbol","symbolKind":"struct","externalID":"s:3GIO7TaskRefV","modules":[{"name":"GIO"}],"navigatorTitle":[{"kind":"identifier","text":"TaskRef"}]},"hierarchy":{"paths":[["doc:\/\/GIO\/documentation\/GIO"]]},"topicSections":[{"title":"Initializers","identifiers":["doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(_:)-32s71","doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(_:)-4ds1b","doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(_:)-69ozl","doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(_:)-7lz59","doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(_:)-o7qi","doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(cPointer:)","doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(constPointer:)","doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(gconstpointer:)","doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(gpointer:)","doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(mutating:)","doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(opaquePointer:)","doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(sourceObject:cancellable:callback:callbackData:)"]},{"title":"Instance Properties","identifiers":["doc:\/\/GIO\/documentation\/GIO\/TaskRef\/ptr"]},{"title":"Type Methods","identifiers":["doc:\/\/GIO\/documentation\/GIO\/TaskRef\/unowned(_:)"]},{"title":"Default Implementations","identifiers":["doc:\/\/GIO\/documentation\/GIO\/TaskRef\/AsyncResultProtocol-Implementations","doc:\/\/GIO\/documentation\/GIO\/TaskRef\/GWeakCapturing-Implementations","doc:\/\/GIO\/documentation\/GIO\/TaskRef\/ObjectProtocol-Implementations","doc:\/\/GIO\/documentation\/GIO\/TaskRef\/TaskProtocol-Implementations"],"generated":true}],"references":{"doc://GIO/documentation/GIO/TaskRef/ptr":{"role":"symbol","title":"ptr","fragments":[{"kind":"keyword","text":"let"},{"kind":"text","text":" "},{"kind":"identifier","text":"ptr"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UnsafeMutableRawPointer","preciseIdentifier":"s:Sv"},{"kind":"text","text":"!"}],"abstract":[{"type":"text","text":"Untyped pointer to the underlying "},{"type":"codeVoice","code":"GTask"},{"type":"text","text":" instance."},{"type":"text","text":" "},{"type":"text","text":"For type-safe access, use the generated, typed pointer "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskProtocol\/task_ptr-2ullq"},{"type":"text","text":" property instead."}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/ptr","kind":"symbol","type":"topic","url":"\/documentation\/gio\/taskref\/ptr"},"doc://GIO/documentation/GIO/TaskProtocol/task_ptr-2ullq":{"defaultImplementations":1,"role":"symbol","title":"task_ptr","fragments":[{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"task_ptr"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UnsafeMutablePointer","preciseIdentifier":"s:Sp"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"GTask"},{"kind":"text","text":">!"}],"abstract":[{"type":"text","text":"Typed pointer to the underlying "},{"type":"codeVoice","code":"GTask"},{"type":"text","text":" instance."}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskProtocol\/task_ptr-2ullq","kind":"symbol","required":true,"type":"topic","url":"\/documentation\/gio\/taskprotocol\/task_ptr-2ullq"},"doc://GIO/documentation/GIO/Task":{"role":"symbol","title":"Task","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"Task"}],"abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"GTask"},{"type":"text","text":" represents and manages a cancellable ‘task’."}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/Task","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Task"}],"url":"\/documentation\/gio\/task"},"doc://GIO/documentation/GIO/TaskRef/init(_:)-o7qi":{"role":"symbol","title":"init(_:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"T"},{"kind":"text","text":">("},{"kind":"typeIdentifier","text":"T"},{"kind":"text","text":")"}],"abstract":[{"type":"text","text":"Reference intialiser for a related type that implements "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskProtocol"}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(_:)-o7qi","kind":"symbol","type":"topic","url":"\/documentation\/gio\/taskref\/init(_:)-o7qi"},"doc://GIO/documentation/GIO/TaskRef/init(_:)-69ozl":{"role":"symbol","title":"init(_:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"UnsafePointer","preciseIdentifier":"s:SP"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"GTask"},{"kind":"text","text":">)"}],"abstract":[{"type":"text","text":"Designated initialiser from a constant pointer to the underlying "},{"type":"codeVoice","code":"C"},{"type":"text","text":" data type"}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(_:)-69ozl","kind":"symbol","type":"topic","url":"\/documentation\/gio\/taskref\/init(_:)-69ozl"},"doc://GIO/10GLibObject14GWeakCapturingP":{"type":"unresolvable","title":"GLibObject.GWeakCapturing","identifier":"doc:\/\/GIO\/10GLibObject14GWeakCapturingP"},"doc://GIO/documentation/GIO":{"role":"collection","title":"GIO","abstract":[],"identifier":"doc:\/\/GIO\/documentation\/GIO","kind":"symbol","type":"topic","url":"\/documentation\/gio"},"doc://GIO/4GLib14PointerWrapperP":{"type":"unresolvable","title":"GLib.PointerWrapper","identifier":"doc:\/\/GIO\/4GLib14PointerWrapperP"},"doc://GIO/documentation/GIO/TaskRef/init(_:)-4ds1b":{"role":"symbol","title":"init(_:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"UnsafeMutablePointer","preciseIdentifier":"s:Sp"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"GTask"},{"kind":"text","text":">)"}],"abstract":[{"type":"text","text":"Designated initialiser from the underlying "},{"type":"codeVoice","code":"C"},{"type":"text","text":" data type"}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(_:)-4ds1b","kind":"symbol","type":"topic","url":"\/documentation\/gio\/taskref\/init(_:)-4ds1b"},"doc://GIO/documentation/GIO/TaskRef/init(opaquePointer:)":{"role":"symbol","title":"init(opaquePointer:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"("},{"kind":"externalParam","text":"opaquePointer"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"OpaquePointer","preciseIdentifier":"s:s13OpaquePointerV"},{"kind":"text","text":")"}],"abstract":[{"type":"text","text":"Unsafe untyped initialiser."},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"text","text":"Do not use unless you know the underlying data type the pointer points to conforms to "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskProtocol"},{"type":"text","text":"."}]}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(opaquePointer:)","kind":"symbol","type":"topic","url":"\/documentation\/gio\/taskref\/init(opaquepointer:)"},"doc://GIO/documentation/GIO/TaskRef/init(cPointer:)":{"role":"symbol","title":"init(cPointer:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"T"},{"kind":"text","text":">("},{"kind":"externalParam","text":"cPointer"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UnsafeMutablePointer","preciseIdentifier":"s:Sp"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"T"},{"kind":"text","text":">)"}],"abstract":[{"type":"text","text":"Unsafe typed initialiser."},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"text","text":"Do not use unless you know the underlying data type the pointer points to conforms to "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskProtocol"},{"type":"text","text":"."}]}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(cPointer:)","kind":"symbol","type":"topic","url":"\/documentation\/gio\/taskref\/init(cpointer:)"},"doc://GIO/documentation/GIO/TaskRef/init(sourceObject:cancellable:callback:callbackData:)":{"role":"symbol","title":"init(sourceObject:cancellable:callback:callbackData:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"CancellableT"},{"kind":"text","text":", "},{"kind":"genericParameter","text":"GObjectObjectT"},{"kind":"text","text":">("},{"kind":"externalParam","text":"sourceObject"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"GObjectObjectT"},{"kind":"text","text":"?, "},{"kind":"externalParam","text":"cancellable"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"CancellableT"},{"kind":"text","text":"?, "},{"kind":"externalParam","text":"callback"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"GAsyncReadyCallback","preciseIdentifier":"c:@T@GAsyncReadyCallback"},{"kind":"text","text":"?, "},{"kind":"externalParam","text":"callbackData"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"gpointer","preciseIdentifier":"c:gtypes.h@T@gpointer"},{"kind":"text","text":"?)"}],"abstract":[{"type":"text","text":"Creates a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Task"},{"type":"text","text":" acting on "},{"type":"codeVoice","code":"sourceObject"},{"type":"text","text":", which will eventually be"},{"type":"text","text":" "},{"type":"text","text":"used to invoke "},{"type":"codeVoice","code":"callback"},{"type":"text","text":" in the current"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"#g-main-context-push-thread-default"},{"type":"text","text":"."}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(sourceObject:cancellable:callback:callbackData:)","kind":"symbol","type":"topic","url":"\/documentation\/gio\/taskref\/init(sourceobject:cancellable:callback:callbackdata:)"},"doc://GIO/documentation/GIO/Cancellable":{"role":"symbol","title":"Cancellable","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"Cancellable"}],"abstract":[{"type":"codeVoice","code":"GCancellable"},{"type":"text","text":" allows operations to be cancelled."}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/Cancellable","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Cancellable"}],"url":"\/documentation\/gio\/cancellable"},"//documentation/glib/maincontext].":{"title":"MainContext","titleInlineContent":[{"type":"text","text":"MainContext"}],"type":"link","identifier":"\/\/documentation\/glib\/maincontext].","url":"\/\/documentation\/glib\/maincontext]."},"iface.AsyncResult.html#io-priority":{"title":"I\/O priority","titleInlineContent":[{"type":"text","text":"I\/O priority"}],"type":"link","identifier":"iface.AsyncResult.html#io-priority","url":"iface.AsyncResult.html#io-priority"},"#g-main-context-push-thread-default":{"title":"thread-default main context","titleInlineContent":[{"type":"text","text":"thread-default main context"}],"type":"link","identifier":"#g-main-context-push-thread-default","url":"#g-main-context-push-thread-default"},"doc://GIO/documentation/GIO/SimpleAsyncResult":{"role":"symbol","title":"SimpleAsyncResult","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"SimpleAsyncResult"}],"abstract":[{"type":"text","text":"As of GLib 2.46, "},{"type":"codeVoice","code":"GSimpleAsyncResult"},{"type":"text","text":" is deprecated in favor of"},{"type":"text","text":" "},{"type":"text","text":"[class"},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Task"},{"type":"text","text":"], which provides a simpler API."}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/SimpleAsyncResult","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"SimpleAsyncResult"}],"url":"\/documentation\/gio\/simpleasyncresult"},"doc://GIO/documentation/GIO/TaskRef":{"role":"symbol","title":"TaskRef","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"TaskRef"}],"abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"GTask"},{"type":"text","text":" represents and manages a cancellable ‘task’."}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"TaskRef"}],"url":"\/documentation\/gio\/taskref"},"doc://GIO/documentation/GIO/TaskRef/ObjectProtocol-Implementations":{"role":"collectionGroup","title":"ObjectProtocol Implementations","abstract":[],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/ObjectProtocol-Implementations","kind":"article","type":"topic","url":"\/documentation\/gio\/taskref\/objectprotocol-implementations"},"doc://GIO/documentation/GIO/AsyncResult":{"role":"symbol","title":"AsyncResult","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"AsyncResult"}],"abstract":[{"type":"codeVoice","code":"GAsyncResult"},{"type":"text","text":" provides a base class for implementing asynchronous function results."}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/AsyncResult","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"AsyncResult"}],"url":"\/documentation\/gio\/asyncresult"},"doc://GIO/documentation/GIO/TaskRef/unowned(_:)":{"role":"symbol","title":"unowned(_:)","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"unowned"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"T"},{"kind":"text","text":">("},{"kind":"typeIdentifier","text":"T"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"TaskRef","preciseIdentifier":"s:3GIO7TaskRefV"}],"abstract":[{"type":"text","text":"This factory is syntactic sugar for setting weak pointers wrapped in "},{"type":"codeVoice","code":"GWeak<T>"}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/unowned(_:)","kind":"symbol","type":"topic","url":"\/documentation\/gio\/taskref\/unowned(_:)"},"doc://GIO/documentation/GIO/TaskRef/TaskProtocol-Implementations":{"role":"collectionGroup","title":"TaskProtocol Implementations","abstract":[],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/TaskProtocol-Implementations","kind":"article","type":"topic","url":"\/documentation\/gio\/taskref\/taskprotocol-implementations"},"doc://GIO/documentation/GIO/TaskRef/init(constPointer:)":{"role":"symbol","title":"init(constPointer:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"T"},{"kind":"text","text":">("},{"kind":"externalParam","text":"constPointer"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UnsafePointer","preciseIdentifier":"s:SP"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"T"},{"kind":"text","text":">)"}],"abstract":[{"type":"text","text":"Unsafe typed initialiser."},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"text","text":"Do not use unless you know the underlying data type the pointer points to conforms to "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskProtocol"},{"type":"text","text":"."}]}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(constPointer:)","kind":"symbol","type":"topic","url":"\/documentation\/gio\/taskref\/init(constpointer:)"},"doc://GIO/documentation/GIO/TaskRef/GWeakCapturing-Implementations":{"role":"collectionGroup","title":"GWeakCapturing Implementations","abstract":[],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/GWeakCapturing-Implementations","kind":"article","type":"topic","url":"\/documentation\/gio\/taskref\/gweakcapturing-implementations"},"doc://GIO/documentation/GIO/TaskRef/init(_:)-7lz59":{"role":"symbol","title":"init(_:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"!("},{"kind":"typeIdentifier","text":"UnsafePointer","preciseIdentifier":"s:SP"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"GTask"},{"kind":"text","text":">?)"}],"abstract":[{"type":"text","text":"Conditional initialiser from an optional, non-mutable pointer to the underlying "},{"type":"codeVoice","code":"C"},{"type":"text","text":" data type"}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(_:)-7lz59","kind":"symbol","type":"topic","url":"\/documentation\/gio\/taskref\/init(_:)-7lz59"},"doc://GIO/documentation/GIO/TaskRef/AsyncResultProtocol-Implementations":{"role":"collectionGroup","title":"AsyncResultProtocol Implementations","abstract":[],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/AsyncResultProtocol-Implementations","kind":"article","type":"topic","url":"\/documentation\/gio\/taskref\/asyncresultprotocol-implementations"},"doc://GIO/documentation/GIO/AsyncResultProtocol":{"role":"symbol","title":"AsyncResultProtocol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"AsyncResultProtocol"}],"abstract":[{"type":"codeVoice","code":"GAsyncResult"},{"type":"text","text":" provides a base class for implementing asynchronous function results."}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/AsyncResultProtocol","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"AsyncResultProtocol"}],"url":"\/documentation\/gio\/asyncresultprotocol"},"doc://GIO/documentation/GIO/TaskRef/init(mutating:)":{"role":"symbol","title":"init(mutating:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"("},{"kind":"externalParam","text":"mutating"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UnsafeRawPointer","preciseIdentifier":"s:SV"},{"kind":"text","text":")"}],"abstract":[{"type":"text","text":"Unsafe untyped initialiser."},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"text","text":"Do not use unless you know the underlying data type the pointer points to conforms to "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskProtocol"},{"type":"text","text":"."}]}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(mutating:)","kind":"symbol","type":"topic","url":"\/documentation\/gio\/taskref\/init(mutating:)"},"doc://GIO/10GLibObject0B8ProtocolP":{"type":"unresolvable","title":"GLibObject.ObjectProtocol","identifier":"doc:\/\/GIO\/10GLibObject0B8ProtocolP"},"doc://GIO/documentation/GIO/TaskRef/init(gpointer:)":{"role":"symbol","title":"init(gpointer:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"!("},{"kind":"externalParam","text":"gpointer"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"gpointer","preciseIdentifier":"c:gtypes.h@T@gpointer"},{"kind":"text","text":"?)"}],"abstract":[{"type":"text","text":"Conditional initialiser from an optional "},{"type":"codeVoice","code":"gpointer"}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(gpointer:)","kind":"symbol","type":"topic","url":"\/documentation\/gio\/taskref\/init(gpointer:)"},"doc://GIO/documentation/GIO/TaskRef/init(gconstpointer:)":{"role":"symbol","title":"init(gconstpointer:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"!("},{"kind":"externalParam","text":"gconstpointer"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"gconstpointer","preciseIdentifier":"c:gtypes.h@T@gconstpointer"},{"kind":"text","text":"?)"}],"abstract":[{"type":"text","text":"Conditional initialiser from an optional, non-mutable "},{"type":"codeVoice","code":"gconstpointer"}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(gconstpointer:)","kind":"symbol","type":"topic","url":"\/documentation\/gio\/taskref\/init(gconstpointer:)"},"doc://GIO/documentation/GIO/TaskRef/init(_:)-32s71":{"role":"symbol","title":"init(_:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"!("},{"kind":"typeIdentifier","text":"UnsafeMutablePointer","preciseIdentifier":"s:Sp"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"GTask"},{"kind":"text","text":">?)"}],"abstract":[{"type":"text","text":"Conditional initialiser from an optional pointer to the underlying "},{"type":"codeVoice","code":"C"},{"type":"text","text":" data type"}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(_:)-32s71","kind":"symbol","type":"topic","url":"\/documentation\/gio\/taskref\/init(_:)-32s71"},"doc://GIO/documentation/GIO/TaskProtocol":{"role":"symbol","title":"TaskProtocol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"TaskProtocol"}],"abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"GTask"},{"type":"text","text":" represents and manages a cancellable ‘task’."}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskProtocol","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"TaskProtocol"}],"url":"\/documentation\/gio\/taskprotocol"}}}